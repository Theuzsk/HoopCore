import discord
from discord import app_commands
from discord.ext import commands
from typing import Optional
import asyncio
from datetime import datetime
from database import Database
from utils import EmbedBuilder, ButtonBuilder, GameLogic
from config import COLORS, EMOJIS, ECONOMY, MATCH_SETTINGS
import random

class MatchesCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.db = Database()
        self.active_matches = {}  # Armazena partidas ativas
    
    @app_commands.command(name="desafiar", description="Desafia outro jogador para uma partida")
    @app_commands.describe(jogador="Mencione o jogador que voc√™ quer desafiar")
    async def challenge_player(self, interaction: discord.Interaction, jogador: discord.Member):
        """Desafia outro jogador para uma partida"""
        await interaction.response.defer()
        
        challenger_id = interaction.user.id
        challenged_id = jogador.id
        
        # Verifica se n√£o est√° desafiando a si mesmo
        if challenger_id == challenged_id:
            embed = EmbedBuilder.create_embed(
                "‚ùå Erro",
                "Voc√™ n√£o pode desafiar a si mesmo!",
                COLORS['error']
            )
            await interaction.followup.send(embed=embed)
            return
        
        # Verifica se ambos t√™m times
        challenger_team = await self.db.get_team(challenger_id)
        challenged_team = await self.db.get_team(challenged_id)
        
        if not challenger_team:
            embed = EmbedBuilder.create_embed(
                "‚ùå Sem Time",
                "Voc√™ precisa criar um time primeiro!",
                COLORS['error']
            )
            await interaction.followup.send(embed=embed)
            return
        
        if not challenged_team:
            embed = EmbedBuilder.create_embed(
                "‚ùå Jogador Sem Time",
                f"{jogador.display_name} ainda n√£o criou um time!",
                COLORS['error']
            )
            await interaction.followup.send(embed=embed)
            return
        
        # Verifica se ambos t√™m jogadores suficientes
        challenger_players = await self.db.get_user_players(challenger_id)
        challenged_players = await self.db.get_user_players(challenged_id)
        
        if len(challenger_players) < 5:
            embed = EmbedBuilder.create_embed(
                "‚ùå Time Incompleto",
                "Voc√™ precisa de pelo menos 5 jogadores para desafiar!",
                COLORS['error']
            )
            await interaction.followup.send(embed=embed)
            return
        
        if len(challenged_players) < 5:
            embed = EmbedBuilder.create_embed(
                "‚ùå Time Incompleto",
                f"{jogador.display_name} precisa de pelo menos 5 jogadores!",
                COLORS['error']
            )
            await interaction.followup.send(embed=embed)
            return
        
        # Cria embed de desafio
        embed = EmbedBuilder.match_embed(
            interaction.user.display_name,
            jogador.display_name,
            0  # Match ID ser√° gerado
        )
        
        # Adiciona informa√ß√µes dos times
        embed.add_field(
            name="üèÄ Times",
            value=f"**{challenger_team['team_name']}** vs **{challenged_team['team_name']}**",
            inline=False
        )
        
        # Adiciona bot√µes de aceitar/recusar
        view = discord.ui.View()
        view.add_item(discord.ui.Button(
            style=discord.ButtonStyle.green,
            label="Aceitar Desafio",
            emoji=EMOJIS['check'],
            custom_id=f"accept_challenge_{challenger_id}"
        ))
        view.add_item(discord.ui.Button(
            style=discord.ButtonStyle.red,
            label="Recusar Desafio",
            emoji=EMOJIS['cross'],
            custom_id=f"decline_challenge_{challenger_id}"
        ))
        
        await interaction.followup.send(
            f"{jogador.mention} voc√™ foi desafiado!",
            embed=embed,
            view=view
        )
    
    @app_commands.command(name="partida", description="Inicia uma partida simulada")
    async def start_match(self, interaction: discord.Interaction):
        """Inicia uma partida simulada"""
        await interaction.response.defer()
        
        user_id = interaction.user.id
        
        # Verifica se tem time
        team = await self.db.get_team(user_id)
        if not team:
            embed = EmbedBuilder.create_embed(
                "‚ùå Sem Time",
                "Voc√™ precisa criar um time primeiro!",
                COLORS['error']
            )
            await interaction.followup.send(embed=embed)
            return
        
        # Verifica se tem 5 titulares
        players = await self.db.get_user_players(user_id)
        starters = [p for p in players if p['is_starter']]
        
        if len(starters) < 5:
            embed = EmbedBuilder.create_embed(
                "‚ö†Ô∏è Time Incompleto",
                f"Voc√™ precisa de 5 titulares para jogar. Atualmente tem {len(starters)}.",
                COLORS['warning']
            )
            await interaction.followup.send(embed=embed)
            return
        
        # Inicia a partida
        await self.start_interactive_match(interaction, team, starters)
    
    async def start_interactive_match(self, interaction, team, starters):
        """Inicia partida interativa"""
        # Calcula overall do time
        team_overall = sum(p['overall'] for p in starters) / len(starters)
        
        # Cria embed inicial da partida
        embed = discord.Embed(
            title="üèÄ Partida Iniciada!",
            description=f"**{team['team_name']}** vs **CPU**\n\n"
                       f"Overall do Time: **{team_overall:.1f}**\n"
                       f"Quartos: 4 x 12 minutos\n\n"
                       f"Clique em **Iniciar** para come√ßar!",
            color=0x00ff00
        )
        
        # Bot√£o para iniciar
        view = discord.ui.View()
        view.add_item(discord.ui.Button(
            style=discord.ButtonStyle.green,
            label="üöÄ Iniciar Partida",
            emoji="üèÄ",
            custom_id="start_match"
        ))
        
        await interaction.followup.send(embed=embed, view=view)
    
    async def handle_match_situation(self, interaction, quarter, time, score_player, score_cpu):
        """Lida com situa√ß√£o da partida"""
        # Situa√ß√µes variadas baseadas no momento da partida
        situations = [
            {
                "name": "üèÄ Ataque R√°pido",
                "description": "Seu time tem uma chance de contra-ataque!",
                "options": [
                    {"label": "‚ö° Correr para a cesta", "custom_id": "fast_break_run", "success_rate": 0.7},
                    {"label": "üéØ Passar para o ala", "custom_id": "fast_break_pass", "success_rate": 0.8},
                    {"label": "üèÉ‚Äç‚ôÇÔ∏è Drible e finaliza√ß√£o", "custom_id": "fast_break_dribble", "success_rate": 0.6}
                ]
            },
            {
                "name": "üéØ Arremesso de 3 Pontos",
                "description": "Chance de arremesso de longa dist√¢ncia!",
                "options": [
                    {"label": "üéØ Arremesso limpo", "custom_id": "three_clean", "success_rate": 0.4},
                    {"label": "üèÉ‚Äç‚ôÇÔ∏è Drible e arremesso", "custom_id": "three_dribble", "success_rate": 0.3},
                    {"label": "ü§ù Passar para melhor posi√ß√£o", "custom_id": "three_pass", "success_rate": 0.9}
                ]
            },
            {
                "name": "üí™ Jogo Interior",
                "description": "Chance de jogada pr√≥xima √† cesta!",
                "options": [
                    {"label": "üèÄ Hook shot", "custom_id": "inside_hook", "success_rate": 0.6},
                    {"label": "üí™ Post-up", "custom_id": "inside_post", "success_rate": 0.7},
                    {"label": "üîÑ Girar e finalizar", "custom_id": "inside_spin", "success_rate": 0.5}
                ]
            },
            {
                "name": "üõ°Ô∏è Defesa",
                "description": "O advers√°rio est√° atacando!",
                "options": [
                    {"label": "üõ°Ô∏è Bloqueio", "custom_id": "defense_block", "success_rate": 0.3},
                    {"label": "üèÉ‚Äç‚ôÇÔ∏è Roubar a bola", "custom_id": "defense_steal", "success_rate": 0.4},
                    {"label": "üìè For√ßar arremesso ruim", "custom_id": "defense_contest", "success_rate": 0.7}
                ]
            },
            {
                "name": "üé≠ Jogada Especial",
                "description": "Chance de uma jogada espetacular!",
                "options": [
                    {"label": "üî• Alley-oop", "custom_id": "special_alley", "success_rate": 0.2},
                    {"label": "üí´ Crossover", "custom_id": "special_crossover", "success_rate": 0.4},
                    {"label": "üöÄ Tomahawk dunk", "custom_id": "special_tomahawk", "success_rate": 0.3}
                ]
            },
            {
                "name": "‚è∞ Final de Quarto",
                "description": "√öltima chance do quarto!",
                "options": [
                    {"label": "üéØ Arremesso de 3", "custom_id": "quarter_three", "success_rate": 0.3},
                    {"label": "üèÉ‚Äç‚ôÇÔ∏è Penetra√ß√£o", "custom_id": "quarter_drive", "success_rate": 0.6},
                    {"label": "ü§ù Passar para finaliza√ß√£o", "custom_id": "quarter_pass", "success_rate": 0.8}
                ]
            }
        ]
        
        # Escolhe situa√ß√£o baseada no momento
        if quarter == 4 and time <= 60:  # Final do jogo
            situation = situations[5]  # Final de quarto
        elif time <= 30:  # Final do quarto
            situation = situations[5]  # Final de quarto
        elif score_player > score_cpu + 10:  # Time na frente
            situation = random.choice(situations[0:3])  # Ataque
        elif score_cpu > score_player + 10:  # Time atr√°s
            situation = random.choice(situations[0:3])  # Ataque agressivo
        else:  # Jogo equilibrado
            situation = random.choice(situations)
        
        # Cria embed da situa√ß√£o
        embed = discord.Embed(
            title=situation["name"],
            description=f"{situation['description']}\n\n"
                       f"**Quarto {quarter}** | **{time}s** restantes\n"
                       f"**Placar:** {score_player} x {score_cpu}",
            color=0x1e90ff
        )
        
        # Cria bot√µes para as op√ß√µes
        view = discord.ui.View()
        for option in situation["options"]:
            button = discord.ui.Button(
                style=discord.ButtonStyle.primary,
                label=option["label"],
                custom_id=f"match_{option['custom_id']}_{quarter}_{time}_{score_player}_{score_cpu}",
                emoji="üéØ"
            )
            view.add_item(button)
        
        await interaction.response.edit_message(embed=embed, view=view)
    
    async def resolve_match_action(self, interaction, action, quarter, time, score_player, score_cpu):
        """Resolve a a√ß√£o escolhida na partida"""
        # Mapeia a√ß√µes para resultados
        action_results = {
            "fast_break_run": {"success": "üèÉ‚Äç‚ôÇÔ∏è **Contra-ataque perfeito!** +2 pontos", "fail": "‚ùå Defesa interceptou o passe"},
            "fast_break_pass": {"success": "ü§ù **Passe perfeito!** +2 pontos", "fail": "‚ùå Passe interceptado"},
            "fast_break_dribble": {"success": "üèÄ **Drible e finaliza√ß√£o!** +2 pontos", "fail": "‚ùå Bola roubada"},
            
            "three_clean": {"success": "üéØ **Tr√™s pontos!** +3 pontos", "fail": "‚ùå Arremesso errou"},
            "three_dribble": {"success": "üèÉ‚Äç‚ôÇÔ∏è **Tr√™s pontos com drible!** +3 pontos", "fail": "‚ùå Arremesso errou"},
            "three_pass": {"success": "ü§ù **Passe para posi√ß√£o melhor!** +2 pontos", "fail": "‚ùå Passe interceptado"},
            
            "inside_hook": {"success": "üèÄ **Hook shot perfeito!** +2 pontos", "fail": "‚ùå Hook shot errou"},
            "inside_post": {"success": "üí™ **Post-up dominante!** +2 pontos", "fail": "‚ùå Defesa for√ßou erro"},
            "inside_spin": {"success": "üîÑ **Giro e finaliza√ß√£o!** +2 pontos", "fail": "‚ùå Giro perdeu o equil√≠brio"},
            
            "defense_block": {"success": "üõ°Ô∏è **Bloqueio espetacular!** Bola recuperada", "fail": "‚ùå Bloqueio falhou, +2 pontos CPU"},
            "defense_steal": {"success": "üèÉ‚Äç‚ôÇÔ∏è **Roubo de bola!** Contra-ataque", "fail": "‚ùå Roubo falhou, +2 pontos CPU"},
            "defense_contest": {"success": "üìè **Arremesso contestado!** CPU errou", "fail": "‚ùå Contesta√ß√£o falhou, +2 pontos CPU"},
            
            "special_alley": {"success": "üî• **ALLEY-OOP ESPETACULAR!** +3 pontos", "fail": "‚ùå Alley-oop falhou"},
            "special_crossover": {"success": "üí´ **CROSSOVER PERFEITO!** +2 pontos", "fail": "‚ùå Crossover falhou"},
            "special_tomahawk": {"success": "üöÄ **TOMAHAWK DUNK!** +3 pontos", "fail": "‚ùå Dunk falhou"},
            
            "quarter_three": {"success": "üéØ **TR√äS PONTOS NO FINAL!** +3 pontos", "fail": "‚ùå Arremesso final errou"},
            "quarter_drive": {"success": "üèÉ‚Äç‚ôÇÔ∏è **Penetra√ß√£o perfeita!** +2 pontos", "fail": "‚ùå Penetra√ß√£o falhou"},
            "quarter_pass": {"success": "ü§ù **Passe para finaliza√ß√£o!** +2 pontos", "fail": "‚ùå Passe final falhou"}
        }
        
        # Obt√©m resultado da a√ß√£o
        action_key = action.split("_", 1)[1]  # Remove "match_" do in√≠cio
        result = action_results.get(action_key, {"success": "‚úÖ A√ß√£o bem-sucedida!", "fail": "‚ùå A√ß√£o falhou"})
        
        # Simula dados de RPG (1-100)
        roll = random.randint(1, 100)
        
        # Determina sucesso baseado na taxa de sucesso da a√ß√£o
        success_rate = 0.5  # Taxa padr√£o
        for situation in self.get_match_situations():
            for option in situation["options"]:
                if option["custom_id"] == action_key:
                    success_rate = option["success_rate"]
                    break
        
        # Calcula sucesso (roll <= success_rate * 100)
        is_success = roll <= (success_rate * 100)
        
        # Atualiza placar
        if is_success:
            if "pontos" in result["success"]:
                if "+3 pontos" in result["success"]:
                    score_player += 3
                elif "+2 pontos" in result["success"]:
                    score_player += 2
        else:
            if "pontos" in result["fail"]:
                if "+2 pontos" in result["fail"]:
                    score_cpu += 2
                elif "+3 pontos" in result["fail"]:
                    score_cpu += 3
        
        # Cria embed do resultado
        embed = discord.Embed(
            title="üéØ Resultado da Jogada",
            description=f"**Dados:** {roll}/100\n"
                       f"**Taxa de Sucesso:** {success_rate*100:.0f}%\n\n"
                       f"**Resultado:** {result['success'] if is_success else result['fail']}\n\n"
                       f"**Placar Atual:** {score_player} x {score_cpu}",
            color=0x00ff00 if is_success else 0xff0000
        )
        
        # Adiciona informa√ß√µes do jogo
        embed.add_field(
            name="‚è∞ Tempo",
            value=f"Quarto {quarter} | {time}s restantes",
            inline=True
        )
        
        # Bot√£o para continuar
        view = discord.ui.View()
        view.add_item(discord.ui.Button(
            style=discord.ButtonStyle.green,
            label="‚ñ∂Ô∏è Continuar",
            emoji="üèÄ",
            custom_id=f"continue_match_{quarter}_{time}_{score_player}_{score_cpu}"
        ))
        
        await interaction.response.edit_message(embed=embed, view=view)
    
    def get_match_situations(self):
        """Retorna todas as situa√ß√µes poss√≠veis"""
        return [
            {
                "name": "üèÄ Ataque R√°pido",
                "description": "Seu time tem uma chance de contra-ataque!",
                "options": [
                    {"label": "‚ö° Correr para a cesta", "custom_id": "fast_break_run", "success_rate": 0.7},
                    {"label": "üéØ Passar para o ala", "custom_id": "fast_break_pass", "success_rate": 0.8},
                    {"label": "üèÉ‚Äç‚ôÇÔ∏è Drible e finaliza√ß√£o", "custom_id": "fast_break_dribble", "success_rate": 0.6}
                ]
            },
            {
                "name": "üéØ Arremesso de 3 Pontos",
                "description": "Chance de arremesso de longa dist√¢ncia!",
                "options": [
                    {"label": "üéØ Arremesso limpo", "custom_id": "three_clean", "success_rate": 0.4},
                    {"label": "üèÉ‚Äç‚ôÇÔ∏è Drible e arremesso", "custom_id": "three_dribble", "success_rate": 0.3},
                    {"label": "ü§ù Passar para melhor posi√ß√£o", "custom_id": "three_pass", "success_rate": 0.9}
                ]
            },
            {
                "name": "üí™ Jogo Interior",
                "description": "Chance de jogada pr√≥xima √† cesta!",
                "options": [
                    {"label": "üèÄ Hook shot", "custom_id": "inside_hook", "success_rate": 0.6},
                    {"label": "üí™ Post-up", "custom_id": "inside_post", "success_rate": 0.7},
                    {"label": "üîÑ Girar e finalizar", "custom_id": "inside_spin", "success_rate": 0.5}
                ]
            },
            {
                "name": "üõ°Ô∏è Defesa",
                "description": "O advers√°rio est√° atacando!",
                "options": [
                    {"label": "üõ°Ô∏è Bloqueio", "custom_id": "defense_block", "success_rate": 0.3},
                    {"label": "üèÉ‚Äç‚ôÇÔ∏è Roubar a bola", "custom_id": "defense_steal", "success_rate": 0.4},
                    {"label": "üìè For√ßar arremesso ruim", "custom_id": "defense_contest", "success_rate": 0.7}
                ]
            },
            {
                "name": "üé≠ Jogada Especial",
                "description": "Chance de uma jogada espetacular!",
                "options": [
                    {"label": "üî• Alley-oop", "custom_id": "special_alley", "success_rate": 0.2},
                    {"label": "üí´ Crossover", "custom_id": "special_crossover", "success_rate": 0.4},
                    {"label": "üöÄ Tomahawk dunk", "custom_id": "special_tomahawk", "success_rate": 0.3}
                ]
            },
            {
                "name": "‚è∞ Final de Quarto",
                "description": "√öltima chance do quarto!",
                "options": [
                    {"label": "üéØ Arremesso de 3", "custom_id": "quarter_three", "success_rate": 0.3},
                    {"label": "üèÉ‚Äç‚ôÇÔ∏è Penetra√ß√£o", "custom_id": "quarter_drive", "success_rate": 0.6},
                    {"label": "ü§ù Passar para finaliza√ß√£o", "custom_id": "quarter_pass", "success_rate": 0.8}
                ]
            }
        ]
    
    @app_commands.command(name="ranking", description="Mostra os rankings")
    @app_commands.describe(
        categoria="Tipo de ranking (overall, dinheiro, vitorias)"
    )
    @app_commands.choices(categoria=[
        app_commands.Choice(name="Overall", value="overall"),
        app_commands.Choice(name="Dinheiro", value="money"),
        app_commands.Choice(name="Vit√≥rias", value="wins")
    ])
    async def show_rankings(self, interaction: discord.Interaction, categoria: str = "overall"):
        """Mostra os rankings"""
        await interaction.response.defer()
        
        # Obt√©m rankings
        rankings = await self.db.get_rankings()
        
        if not rankings:
            embed = EmbedBuilder.create_embed(
                "üìä Ranking",
                "Nenhum dado dispon√≠vel para rankings ainda.",
                COLORS['info']
            )
            await interaction.followup.send(embed=embed)
            return
        
        if not rankings.get(categoria) or len(rankings[categoria]) == 0:
            if categoria == "overall":
                message = "Nenhum time com 5 titulares ainda para calcular overall."
            elif categoria == "money":
                message = "Nenhum time criado ainda."
            else:
                message = "Nenhuma partida jogada ainda."
            
            embed = EmbedBuilder.create_embed(
                "üìä Ranking",
                message,
                COLORS['info']
            )
            await interaction.followup.send(embed=embed)
            return
        
        embed = EmbedBuilder.ranking_embed(rankings, categoria)
        
        # Adiciona bot√µes para outros rankings
        view = discord.ui.View()
        view.add_item(discord.ui.Button(
            style=discord.ButtonStyle.primary,
            label="Overall",
            custom_id="ranking_overall"
        ))
        view.add_item(discord.ui.Button(
            style=discord.ButtonStyle.success,
            label="Dinheiro",
            custom_id="ranking_money"
        ))
        view.add_item(discord.ui.Button(
            style=discord.ButtonStyle.secondary,
            label="Vit√≥rias",
            custom_id="ranking_wins"
        ))
        
        await interaction.followup.send(embed=embed, view=view)
    
    @app_commands.command(name="estatisticas", description="Mostra suas estat√≠sticas")
    async def show_stats(self, interaction: discord.Interaction):
        """Mostra estat√≠sticas do usu√°rio"""
        await interaction.response.defer()
        
        user_id = interaction.user.id
        
        # Verifica se tem time
        team = await self.db.get_team(user_id)
        if not team:
            embed = EmbedBuilder.create_embed(
                "‚ùå Sem Time",
                "Voc√™ ainda n√£o criou um time!",
                COLORS['error']
            )
            await interaction.followup.send(embed=embed)
            return
        
        # Obt√©m dados do usu√°rio
        user = await self.db.get_user(user_id)
        players = await self.db.get_user_players(user_id)
        
        # Calcula estat√≠sticas
        total_players = len(players)
        starters = [p for p in players if p['is_starter']]
        avg_overall = GameLogic.calculate_team_overall(starters) if starters else 0
        
        # Conta jogadores por raridade
        rarity_counts = {}
        for player in players:
            rarity = player['rarity']
            rarity_counts[rarity] = rarity_counts.get(rarity, 0) + 1
        
        # Cria embed
        embed = EmbedBuilder.create_embed(
            f"{EMOJIS['stats']} Estat√≠sticas - {team['team_name']}",
            f"Estat√≠sticas detalhadas do seu time",
            COLORS['primary']
        )
        
        embed.add_field(
            name="üìä Record",
            value=f"**Vit√≥rias:** {team['wins']}\n**Derrotas:** {team['losses']}\n**Win Rate:** {(team['wins']/(team['wins']+team['losses'])*100):.1f}%" if (team['wins']+team['losses']) > 0 else "0%",
            inline=True
        )
        
        embed.add_field(
            name="üí∞ Economia",
            value=f"**Dinheiro:** ${user['money']:,}\n**Jogadores:** {total_players}\n**Titulares:** {len(starters)}/5",
            inline=True
        )
        
        embed.add_field(
            name="üèÄ Time",
            value=f"**Overall M√©dio:** {avg_overall:.1f}\n**Melhor Jogador:** {max(players, key=lambda x: x['overall'])['name'] if players else 'N/A'}",
            inline=True
        )
        
        # Adiciona distribui√ß√£o por raridade
        if rarity_counts:
            rarity_text = ""
            for rarity, count in rarity_counts.items():
                rarity_emoji = {'comum': '‚ö™', 'raro': 'üîµ', '√©pico': 'üü£', 'lend√°rio': 'üü°'}
                rarity_text += f"{rarity_emoji.get(rarity, '‚ö™')} {rarity}: {count}\n"
            
            embed.add_field(
                name="‚≠ê Raridades",
                value=rarity_text,
                inline=False
            )
        
        await interaction.followup.send(embed=embed)
    
    @app_commands.command(name="historico", description="Mostra hist√≥rico de partidas")
    async def show_match_history(self, interaction: discord.Interaction):
        """Mostra hist√≥rico de partidas"""
        await interaction.response.defer()
        
        user_id = interaction.user.id
        
        # Verifica se tem time
        team = await self.db.get_team(user_id)
        if not team:
            embed = EmbedBuilder.create_embed(
                "‚ùå Sem Time",
                "Voc√™ ainda n√£o criou um time!",
                COLORS['error']
            )
            await interaction.followup.send(embed=embed)
            return
        
        # Por enquanto, mostra estat√≠sticas b√°sicas
        # (implementar hist√≥rico completo no database)
        
        embed = EmbedBuilder.create_embed(
            f"{EMOJIS['game']} Hist√≥rico de Partidas",
            f"Hist√≥rico de partidas do {team['team_name']}",
            COLORS['info']
        )
        
        embed.add_field(
            name="üìä Resumo",
            value=f"**Total de Partidas:** {team['wins'] + team['losses']}\n"
                  f"**Vit√≥rias:** {team['wins']}\n"
                  f"**Derrotas:** {team['losses']}\n"
                  f"**Win Rate:** {(team['wins']/(team['wins']+team['losses'])*100):.1f}%" if (team['wins']+team['losses']) > 0 else "0%",
            inline=False
        )
        
        embed.add_field(
            name="‚ÑπÔ∏è Informa√ß√£o",
            value="Hist√≥rico detalhado de partidas ser√° implementado em breve!",
            inline=False
        )
        
        await interaction.followup.send(embed=embed)

async def setup(bot):
    await bot.add_cog(MatchesCog(bot))
